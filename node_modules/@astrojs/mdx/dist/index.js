import { compile as mdxCompile, nodeTypes } from "@mdx-js/mdx";
import mdxPlugin from "@mdx-js/rollup";
import { parse as parseESM } from "es-module-lexer";
import rehypeRaw from "rehype-raw";
import remarkGfm from "remark-gfm";
import remarkSmartypants from "remark-smartypants";
import { VFile } from "vfile";
import { rehypeApplyFrontmatterExport, remarkInitializeAstroData } from "./astro-data-utils.js";
import rehypeCollectHeadings from "./rehype-collect-headings.js";
import remarkPrism from "./remark-prism.js";
import remarkShiki from "./remark-shiki.js";
import { getFileInfo, parseFrontmatter } from "./utils.js";
const DEFAULT_REMARK_PLUGINS = [
  remarkGfm,
  remarkSmartypants
];
const DEFAULT_REHYPE_PLUGINS = [];
const RAW_CONTENT_ERROR = "MDX does not support rawContent()! If you need to read the Markdown contents to calculate values (ex. reading time), we suggest injecting frontmatter via remark plugins. Learn more on our docs: https://docs.astro.build/en/guides/integrations-guide/mdx/#inject-frontmatter-via-remark-or-rehype-plugins";
const COMPILED_CONTENT_ERROR = "MDX does not support compiledContent()! If you need to read the HTML contents to calculate values (ex. reading time), we suggest injecting frontmatter via rehype plugins. Learn more on our docs: https://docs.astro.build/en/guides/integrations-guide/mdx/#inject-frontmatter-via-remark-or-rehype-plugins";
function handleExtends(config, defaults = []) {
  if (Array.isArray(config))
    return config;
  return [...defaults, ...(config == null ? void 0 : config.extends) ?? []];
}
async function getRemarkPlugins(mdxOptions, config) {
  let remarkPlugins = [
    remarkInitializeAstroData,
    ...handleExtends(mdxOptions.remarkPlugins, DEFAULT_REMARK_PLUGINS)
  ];
  if (config.markdown.syntaxHighlight === "shiki") {
    remarkPlugins.push([await remarkShiki(config.markdown.shikiConfig)]);
  }
  if (config.markdown.syntaxHighlight === "prism") {
    remarkPlugins.push(remarkPrism);
  }
  return remarkPlugins;
}
function getRehypePlugins(mdxOptions, config) {
  let rehypePlugins = [
    [rehypeRaw, { passThrough: nodeTypes }],
    ...handleExtends(mdxOptions.rehypePlugins, DEFAULT_REHYPE_PLUGINS)
  ];
  rehypePlugins.unshift(rehypeCollectHeadings);
  return rehypePlugins;
}
function mdx(mdxOptions = {}) {
  return {
    name: "@astrojs/mdx",
    hooks: {
      "astro:config:setup": async ({ updateConfig, config, addPageExtension, command }) => {
        addPageExtension(".mdx");
        const mdxPluginOpts = {
          remarkPlugins: await getRemarkPlugins(mdxOptions, config),
          rehypePlugins: getRehypePlugins(mdxOptions, config),
          jsx: true,
          jsxImportSource: "astro",
          format: "mdx",
          mdExtensions: []
        };
        updateConfig({
          vite: {
            plugins: [
              {
                enforce: "pre",
                ...mdxPlugin(mdxPluginOpts),
                async transform(code, id) {
                  if (!id.endsWith("mdx"))
                    return;
                  const { data: frontmatter, content: pageContent } = parseFrontmatter(code, id);
                  const compiled = await mdxCompile(new VFile({ value: pageContent, path: id }), {
                    ...mdxPluginOpts,
                    rehypePlugins: [
                      ...mdxPluginOpts.rehypePlugins ?? [],
                      () => rehypeApplyFrontmatterExport(frontmatter)
                    ]
                  });
                  return {
                    code: String(compiled.value),
                    map: compiled.map
                  };
                }
              },
              {
                name: "@astrojs/mdx-postprocess",
                transform(code, id) {
                  if (!id.endsWith(".mdx"))
                    return;
                  const [, moduleExports] = parseESM(code);
                  const { fileUrl, fileId } = getFileInfo(id, config);
                  if (!moduleExports.includes("url")) {
                    code += `
export const url = ${JSON.stringify(fileUrl)};`;
                  }
                  if (!moduleExports.includes("file")) {
                    code += `
export const file = ${JSON.stringify(fileId)};`;
                  }
                  if (!moduleExports.includes("rawContent")) {
                    code += `
export function rawContent() { throw new Error(${JSON.stringify(
                      RAW_CONTENT_ERROR
                    )}) };`;
                  }
                  if (!moduleExports.includes("compiledContent")) {
                    code += `
export function compiledContent() { throw new Error(${JSON.stringify(
                      COMPILED_CONTENT_ERROR
                    )}) };`;
                  }
                  if (!moduleExports.includes("Content")) {
                    code += `
export const Content = MDXContent;`;
                  }
                  if (command === "dev") {
                    code += `
if (import.meta.hot) {
											import.meta.hot.decline();
										}`;
                  }
                  return code;
                }
              }
            ]
          }
        });
      }
    }
  };
}
export {
  mdx as default
};
